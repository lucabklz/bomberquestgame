package de.tum.cit.ase.bomberquest.map;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import de.tum.cit.ase.bomberquest.audio.SoundEffect;
import de.tum.cit.ase.bomberquest.texture.Animations;
import de.tum.cit.ase.bomberquest.texture.Drawable;


/**
 * Represents a bomb in the game.
 * A bomb has a countdown timer, explodes after a set duration, and creates blasts in all directions.
 */
public class Bomb extends GameObject implements Drawable {

    private float stateTime; // Tracks the animation time of the bomb
    private final int blastRadius; // The radius of the blast generated by the bomb
    private Runnable explode; // Additional logic to execute upon explosion (e.g., game effects)
    private final GameMap map; // Reference to the game map where the bomb exists
    private boolean isPaused = false; // Indicates whether the bomb is paused
    private boolean isExploded = false; // Indicates whether the bomb has already exploded
    private Object bombCreator; // The entity (player or enemy) that placed the bomb

    /**
     * Constructor for the bomb class.
     * Initialize the bomb with its position, blast radius and explosion behavior.
     * Also sets a timer to call the explosion after a fixed delay of 3 seconds.
     *
     * @param x             The x-coordinate of the bomb's position.
     * @param y             The y-coordinate of the bomb's position.
     * @param blastRadius   The radius of the bomb's blast (maximum radius of 8)
     * @param explode       A Runnable task to execute additional logic when the bomb explodes.
     * @param map           The game map where the bomb will be placed.
     * @param bombCreator   The creator of the bomb (player or enemy)
     */
    public Bomb(float x, float y, int blastRadius, Runnable explode, GameMap map, Object bombCreator) {
        super(x, y);
        this.blastRadius = Math.min(blastRadius, 8); // Set the blast radius (maximum of 8 tiles)
        this.explode = explode;
        this.map = map;
        this.stateTime = 0; // Initialize the state time to 0 for animation purposes
        this.bombCreator = bombCreator;
    }

    /**
     * Retrieves the current visual representation of the bomb based on its animation state.
     * @return A TextureRegion representing the current frame of the bomb's animation.
     */
    @Override
    public TextureRegion getCurrentAppearance() {
        return Animations.BOMB_PLACEMENT.getKeyFrame(stateTime, true);
    }

    /**
     * Updates the bomb's state each frame.
     * Handles the countdown timer and triggers the explosion when the timer reaches 3 seconds.
     *
     * @param frameTime The time elapsed since the last frame (in seconds).
     */
    public void tick(float frameTime) {
        // Check if the game is paused or not
        if (!isPaused) {
            // If the game is not paused, increase the bomb's state time based on the passed frame time
            stateTime += frameTime;
            // If the bomb has not yet exploded, the bomb should explode after 3 seconds
            if (!isExploded && stateTime >= 3.0f) {
                // Call the explosion method
                explosion();
            }
        }
    }

    /**
     * Handles the logic for the bomb's explosion.
     * Creates the blast at the bomb's position and propagates it in all directions.
     */
    private void explosion() {
        // Exit the method if the bomb already has exploded
        if (isExploded) {
            return;
        }

        // Set isExploded to true
        isExploded = true;

        // Mark the current bomb for its removal from the game map
        map.markBombForRemoval(Bomb.this);

        // Play the EXDPLOSION sound effect
        SoundEffect.EXPLOSION.play();

        // Center of the explosion
        new Blast(x, y, Animations.BLAST_CENTER, map.getWorld(), this).createBlast(map);

        // Propagate blast in all directions
        propagateBlast((int) x, (int) y, 1, 0, Animations.BLAST_HORIZONTAL_EXTENSION, Animations.BLAST_RIGHT);
        propagateBlast((int) x, (int) y, -1, 0, Animations.BLAST_HORIZONTAL_EXTENSION, Animations.BLAST_LEFT);
        propagateBlast((int) x, (int) y, 0, 1, Animations.BLAST_VERTICAL_EXTENSION, Animations.BLAST_UP);
        propagateBlast((int) x, (int) y, 0, -1, Animations.BLAST_VERTICAL_EXTENSION, Animations.BLAST_DOWN);

        // Trigger any additional explosion-related effects or logic
        explode.run();
    }

    /**
     * Propagates the blast in a specified direction.
     * Creates blasts at each tile within the blast radius, stopping at obstacles.
     *
     * @param startX    The starting x-coordinate of the blast.
     * @param startY    The starting y-coordinate of the blast.
     * @param dx        The x-direction of the blast (e.g., 1 for right, -1 for left).
     * @param dy        The y-direction of the blast (e.g., 1 for up, -1 for down).
     * @param extension The animation for the mid-section of the blast.
     * @param end       The animation for the end of the blast.
     */
    private void propagateBlast(int startX, int startY, int dx, int dy, Animation<TextureRegion> extension, Animation<TextureRegion> end) {
        for (int i = 1; i <= blastRadius; i++) {
            int currentX = startX + i * dx;
            int currentY = startY + i * dy;

            // If blocked by indestructible wall, the blast should be stopped
            if (map.isBlocked(currentX, currentY)) {
                break;
            }

            // If blocked by destructible wall, destroy it and create blast
            if (map.isDestructibleWall(currentX, currentY)) {
                map.destroyDestructibleWall(currentX, currentY);
                new Blast(currentX, currentY, end, map.getWorld(), this).createBlast(map);
            }

            // If not blocked, add mid-section or end blast depending on radius
            if (i == blastRadius) {
                new Blast(currentX, currentY, end, map.getWorld(), this).createBlast(map); // End blast
            } else {
                new Blast(currentX, currentY, extension, map.getWorld(), this).createBlast(map); // Mid-section blast
            }
        }
    }

    /**
     * Disposes resources used by this object to free up memory and avoid memory leaks.
     * This method should be called when the object is no longer needed.
     */
    public void dispose() {
        if (map != null) {
            map.getBombs().remove(this);
        }
        explode = null;
    }

    /**
     * Pauses or resumes the bomb's timer and animation.
     * @param paused True to pause the bomb; false to resume its countdown.
     */
    public void setPaused(boolean paused) {
        isPaused = paused;
    }

    /**
     * Retrieves the x-coordinate of the bomb's position.
     *
     * @return The x-coordinate of the bomb.
     */
    @Override
    public float getX() {
        return x;
    }

    /**
     * Retrieves the y-coordinate of the bomb's position.
     *
     * @return The y-coordinate of the bomb.
     */
    @Override
    public float getY() {
        return y;
    }

    /**
     * Retrieves the entity (player or enemy) that created the bomb.
     *
     * @return The creator of the bomb.
     */
    public Object getBombCreator() {
        return bombCreator;
    }
}

